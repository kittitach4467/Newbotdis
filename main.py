import os
import discord
import asyncio
import yfinance as yf
from datetime import datetime, time, timedelta
from myserver import server_on

# ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ token ‡∏Ç‡∏≠‡∏á‡∏ö‡∏≠‡∏ó‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà
CHANNEL_ID = '1281951649845477418'  # ID ‡∏Ç‡∏≠‡∏á channel ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÉ‡∏´‡πâ‡∏ö‡∏≠‡∏ó‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°

# ‡∏Å‡∏≥‡∏´‡∏ô‡∏î intents ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå‡∏ï‡πà‡∏≤‡∏á ‡πÜ
intents = discord.Intents.default()
intents.message_content = True  # ‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°

client = discord.Client(intents=intents)

# ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏Å‡πà‡∏≠‡∏ô‡∏ñ‡∏∂‡∏á‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
def time_until_next_target(target_time):
    now = datetime.now()
    target = now.replace(hour=target_time.hour, minute=target_time.minute, second=0, microsecond=0)
    
    if now > target:
        target += timedelta(days=1)  # ‡∏ñ‡πâ‡∏≤‡πÄ‡∏ß‡∏•‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢ ‡πÉ‡∏´‡πâ‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏õ‡∏™‡πà‡∏á‡∏ß‡∏±‡∏ô‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
    return (target - now).total_seconds()

async def send_exchange_rate():
    await client.wait_until_ready()
    channel = client.get_channel(int(CHANNEL_ID))
    times_to_send = [time(hour=h, minute=m) for h in range(0, 24) for m in range(0, 60)]  # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏™‡πà‡∏á‡∏ó‡∏∏‡∏Å‡∏ô‡∏≤‡∏ó‡∏µ

    while not client.is_closed():
        now = datetime.now().time()

        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏ß‡∏•‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        for target_time in times_to_send:
            if now.hour == target_time.hour and now.minute == target_time.minute:
                try:
                    # ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å yfinance ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡πÄ‡∏á‡∏¥‡∏ô USD/THB
                    data = yf.download('USDTHB=X', period='1d', interval='1m')
                    last_rate = data['Close'][-1]  # ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
                    
                    # ‡∏î‡∏∂‡∏á‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏•‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
                    days_of_week = {
                        'Monday': '‡∏ß‡∏±‡∏ô‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå',
                        'Tuesday': '‡∏ß‡∏±‡∏ô‡∏≠‡∏±‡∏á‡∏Ñ‡∏≤‡∏£',
                        'Wednesday': '‡∏ß‡∏±‡∏ô‡∏û‡∏∏‡∏ò',
                        'Thursday': '‡∏ß‡∏±‡∏ô‡∏û‡∏§‡∏´‡∏±‡∏™‡∏ö‡∏î‡∏µ',
                        'Friday': '‡∏ß‡∏±‡∏ô‡∏®‡∏∏‡∏Å‡∏£‡πå',
                        'Saturday': '‡∏ß‡∏±‡∏ô‡πÄ‡∏™‡∏≤‡∏£‡πå',
                        'Sunday': '‡∏ß‡∏±‡∏ô‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå'
                    }
                    now = datetime.now()
                    day_of_week_th = days_of_week.get(now.strftime('%A'), 'Unknown')

                    now_str = now.strftime('%d:%m:%y')
                    now_time = now.strftime('%H:%M:%S')
                    last_m = f"{last_rate:.4f}"
                    
                    # ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏Å‡πÅ‡∏ï‡πà‡∏á
                    message = (
                                f">>> ```css"
                                f"\n*{'-'*33}*"
                                f"\n{'‚òÖ    ‡∏Ñ‡πà‡∏≤‡πÄ‡∏á‡∏¥‡∏ô Bath/USD    ‚òÖ'.center(33)}"
                                f"\n*{'-'*33}*"
                                f"\n{'‚è∞‡πÄ‡∏ß‡∏•‡∏≤'.center(32)}"
                                f"\n{day_of_week_th.center(37)}"
                                f"\n{now_str.center(33)}"
                                f"\n{now_ste.center(33)}"
                                f"\n{'üíµ ‡∏≠‡∏±‡∏ï‡∏£‡∏≤'.center(33)}"
                                f"\n{last_m.center(33)}"
                                f"\n{'‡∏ö‡∏≤‡∏ó/USD'.center(33)}"
                                f"\n*{'-'*33}*"
                                f"\n```"
                            )

                    await channel.send(message)

                except Exception as e:
                    await channel.send(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡πà‡∏≤‡πÄ‡∏á‡∏¥‡∏ô: {str(e)}")

        # ‡∏£‡∏≠‡∏à‡∏ô‡∏ñ‡∏∂‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏ñ‡∏±‡∏î‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
        next_target_time = min(times_to_send, key=lambda t: time_until_next_target(t))
        sleep_duration = time_until_next_target(next_target_time)
        await asyncio.sleep(sleep_duration)

@client.event
async def on_ready():
    print(f'‡∏ö‡∏≠‡∏ó {client.user} ‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏•‡πâ‡∏ß!')
    client.loop.create_task(send_exchange_rate())
    server_on()

client.run(os.getenv('TOKEN'))
